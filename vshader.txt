#version 330

//Zmienne jednorodne
uniform mat4 P;
uniform mat4 V;
uniform mat4 M;
uniform vec4 Przes;


//Atrybuty
in vec4 vertex; //wspolrzedne wierzcholka w przestrzeni modelu
in vec4 color;  //kolor wierzcholka (na razie ignorowany)
in vec4 normal; //wektor normalny w wierzcholku (na razie ignorowany)
out vec4 interC;
 float d;
vec4 wiercholek;

float PI = 3.1415926;

void main(void) {
   // d=distance(V*M*vertex,vec4(0,0,0,1));
   // d=1-((d-3.3)/2);
   // interC =color*vec4(d,d,d,1);

   vec4 lp = vec4(0,30,0,1);
   vec4 l = V*lp - V*M*vertex;
   vec4 n = V*M*normal;
   float c = max(dot(normalize(l),normalize(n)),0);

   interC=color;//*vec4(c,c,c,1);

   //liczenie macierzy przesuniecia
    mat4 Mov = mat4(1.0);
    Mov[3].x=Przes.x;
    Mov[3].z=Przes.z;

    //liczenie macierzy obrotu o 90 stopni, oœ Y

    mat4 Rot = mat4(1.0);
    if(int(Przes.w)==0){
        Rot[0].x=cos(90*Przes.y*PI/180);
        Rot[0].z=-sin(90*Przes.y*PI/180);
        Rot[2].x=sin(90*Przes.y*PI/180);
        Rot[2].z=cos(90*Przes.y*PI/180);

   }

   else{
        Rot[0].x=cos(90*(Przes.w-1.0)*PI/180);
        Rot[0].z=-sin(90*(Przes.w-1.0)*PI/180);
        Rot[2].x=sin(90*(Przes.w-1.0)*PI/180);
        Rot[2].z=cos(90*(Przes.w-1.0)*PI/180);

   }

    mat4 Mod=Mov*Rot;

	gl_Position=P*V*Mod*vertex;

}


